// btsync-cli v0.3 by sergeyfast
package main

import (
	"btsync"
	"flag"
	"fmt"
	"log"
	"path/filepath"
)

const (
	DefaultHost     = "127.0.0.1"
	DefaultPassword = "123456"
)

var host, port, user, password, addPath, delSecret, secret string
var verbose, listFolders, generateSecret, resolvePath bool

// Fatal on Error
func err(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {
	flag.StringVar(&host, "host", DefaultHost, "btsync hostname")
	flag.StringVar(&port, "port", "8888", "btsync port")
	flag.StringVar(&user, "u", "admin", "username")
	flag.StringVar(&password, "p", DefaultPassword, "password")
	flag.StringVar(&addPath, "a", "", "absolute path to add for index (use -r for relative path support)")
	flag.StringVar(&delSecret, "d", "", "delete folder by secret")
	flag.StringVar(&secret, "s", "", "secret, if empty will be autogenerated")
	flag.BoolVar(&listFolders, "l", false, "list folders (secret, read-only secret, type, path)")
	flag.BoolVar(&generateSecret, "g", false, "get new secret (use -s <secret> for readonly)")
	flag.BoolVar(&resolvePath, "r", false, "resolve relative path (for -a)")
	flag.BoolVar(&verbose, "v", false, "verbose mode on")

	flag.Parse()
	btsync.Debug = verbose

	c := btsync.NewClient(host, port, user, password)
	if _, err := c.Version(); err != nil {
		log.Print("Can't get version")
		return
	}

	switch {
	case addPath != "":
		if resolvePath {
			addPath, _ = filepath.Abs(addPath)
		}

		ra, e := c.AddFolder(addPath, secret, 0)
		err(e)

		if ra.Error == 0 && ra.Result == 0 {
			fmt.Println("Folder was added to sync folders")
			fmt.Printf("Error: %d\n", ra.Error)
		} else {
			fmt.Println( ra.Message )
			fmt.Printf("Folder:\t%s\n", addPath)
			fmt.Printf("Status: %d\n", ra.Error)
		}

	case delSecret != "":
		ra, e := c.RemoveFolder(delSecret)
		err(e)

		if ra.Error == 0 && ra.Result == 0 {
			fmt.Println("Folder was removed from sync folders")
			fmt.Printf("Status: %d\n", ra.Error)
		} else {
			fmt.Println( ra.Message )
			fmt.Printf("Folder was not removed by secret:\t%s\n", delSecret)
			fmt.Printf("Status: %d\n", ra.Error)
		}
	case listFolders:
		fi, e := c.Folders()
		err(e)

		if len(fi) > 0 {
			for _, f := range fi {
				s, e := c.Secrets( f.Secret, false )
				if e != nil {
					err(e)
				}

				fmt.Printf("%s\t%s\t%s\t%s\n", f.Secret, s.ReadOnly, f.Type, f.Dir)
			}
		}
	case generateSecret:
		s, e := c.Secrets(secret, false)
		err(e)

		fmt.Printf("Secret:\t%s\n", s.ReadWrite)
		fmt.Printf("RO:\t%s\n", s.ReadOnly)
	case addPath == "":
		log.Fatal("Use -a, -l or -g flags. Flag -h for help.")
	}
}
